<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Auto-sliding Carousel — drag fixed</title>
<style>
  :root { --gap: 12px; --w: 720px; --h: 360px; }
  body { font-family: system-ui, Arial; display: grid; place-items: center; min-height: 100vh; background:#0f1115; color:#eaeaea }
  .carousel { width: min(95vw, var(--w)); }
  .viewport {
    position: relative; overflow: hidden; border-radius: 16px; box-shadow: 0 8px 30px rgba(0,0,0,.35);
    background: #161a22;
  }
  .track {
    display: flex; gap: var(--gap);
    padding: 0 var(--gap);
    touch-action: pan-y;
    will-change: transform;
    user-select: none;
    cursor: grab;
    transition: transform .35s ease;
  }
  .dragging .track { transition: none; cursor: grabbing; }
  .slide {
    flex: 0 0 calc(100% - var(--gap)*2);
    inline-size: calc(100% - var(--gap)*2);
    block-size: var(--h);
    overflow: hidden; border-radius: 12px; background:#0b0d12;
  }
  .slide img { width: 100%; height: 100%; object-fit: cover; display: block; -webkit-user-drag:none; user-drag:none; user-select:none; }
  .controls { display:flex; justify-content: space-between; align-items:center; margin-top:12px; }
  .btn { background:#232838; color:#fff; border:0; padding:10px 14px; border-radius:10px; font-weight:600; cursor:pointer; transition:transform .12s ease, opacity .2s; }
  .btn:active { transform: scale(.98); }
  .dots { display:flex; gap:8px; }
  .dot { width:8px; height:8px; border-radius:999px; background:#3a415a; opacity:.6; }
  .dot.active { background:#9aa5ff; opacity:1; }
</style>
</head>
<body>

<div class="carousel" aria-label="Image carousel">
  <div class="viewport" id="viewport" aria-live="polite">
    <div class="track" id="track">
      <!-- draggable="false" added to images -->
      <div class="slide"><img src="https://picsum.photos/id/1005/1200/600" alt="Slide 1" draggable="false"></div>
      <div class="slide"><img src="https://picsum.photos/id/1015/1200/600" alt="Slide 2" draggable="false"></div>
      <div class="slide"><img src="https://picsum.photos/id/1025/1200/600" alt="Slide 3" draggable="false"></div>
      <div class="slide"><img src="https://picsum.photos/id/1035/1200/600" alt="Slide 4" draggable="false"></div>
    </div>
  </div>
  <div class="controls">
    <button class="btn" id="prev" aria-label="Previous slide">◀</button>
    <div class="dots" id="dots"></div>
    <button class="btn" id="next" aria-label="Next slide">▶</button>
  </div>
</div>

<script>
  const track = document.getElementById('track');
  const viewport = document.getElementById('viewport');
  const slides = Array.from(track.children);
  const prevBtn = document.getElementById('prev');
  const nextBtn = document.getElementById('next');
  const dotsEl = document.getElementById('dots');

  // ensure images are non-draggable (extra safety if HTML doesn't have draggable attr)
  slides.forEach(sl => {
    const img = sl.querySelector('img');
    if (img) {
      img.setAttribute('draggable', 'false');
    }
  });

  // prevent default dragstart for images (global protective measure)
  document.addEventListener('dragstart', (e) => {
    if (e.target && e.target.tagName === 'IMG') e.preventDefault();
  });

  let index = 0;
  let startX = 0;
  let currentX = 0;
  let baseTranslate = 0;
  let dragging = false;
  let autoSlide; // interval holder

  // dots
  const dots = slides.map((_, i) => {
    const d = document.createElement('div');
    d.className = 'dot' + (i === 0 ? ' active' : '');
    d.role = 'button';
    d.ariaLabel = `Go to slide ${i+1}`;
    d.tabIndex = 0;
    d.addEventListener('click', () => { goTo(i); resetAutoSlide(); });
    dotsEl.appendChild(d);
    return d;
  });

  function width() {
    const slide = slides[0];
    const style = getComputedStyle(track);
    const gap = parseFloat(style.gap) || 0;
    return slide.getBoundingClientRect().width + gap;
  }

  function clamp(i) {
    return Math.max(0, Math.min(i, slides.length - 1));
  }

  function update() {
    track.style.transform = `translateX(${-index * width()}px)`;
    dots.forEach((d, i) => d.classList.toggle('active', i === index));
  }

  function goTo(i) {
    index = clamp(i);
    update();
  }

  function next() {
    index = (index + 1) % slides.length;
    update();
  }
  function prev() {
    index = (index - 1 + slides.length) % slides.length;
    update();
  }

  nextBtn.addEventListener('click', () => { next(); resetAutoSlide(); });
  prevBtn.addEventListener('click', () => { prev(); resetAutoSlide(); });

  // Drag logic
  function onDown(clientX, pointerId) {
    dragging = true;
    viewport.classList.add('dragging');
    startX = clientX;
    baseTranslate = -index * width();
    track.style.transition = 'none';
    clearInterval(autoSlide); // stop autoplay while dragging
    if (pointerId !== undefined) {
      try { viewport.setPointerCapture(pointerId); } catch(e){/* ignore if not supported */ }
    }
  }
  function onMove(clientX) {
    if (!dragging) return;
    currentX = clientX;
    const delta = currentX - startX;
    track.style.transform = `translateX(${baseTranslate + delta}px)`;
  }
  function onUp() {
    if (!dragging) return;
    dragging = false;
    viewport.classList.remove('dragging');
    track.style.transition = '';
    const delta = currentX - startX;
    const threshold = width() * 0.2;
    if (delta < -threshold) index++;
    else if (delta > threshold) index--;
    index = clamp(index);
    update();
    resetAutoSlide();
  }

  // pointer events — preventDefault to stop browser image drag
  viewport.addEventListener('pointerdown', e => {
    // prevent browser-native image drag and default touch behaviors
    e.preventDefault();
    if (e.pointerType === 'mouse' || e.pointerType === 'touch' || e.pointerType === 'pen') {
      onDown(e.clientX, e.pointerId);
    }
  });
  viewport.addEventListener('pointermove', e => { if (e.pressure !== 0) onMove(e.clientX); else onMove(e.clientX); });
  viewport.addEventListener('pointerup', onUp);
  viewport.addEventListener('pointercancel', onUp);
  viewport.addEventListener('pointerleave', () => dragging && onUp());

  // Touch fallback (older browsers) — passive:false so preventDefault works
  viewport.addEventListener('touchstart', e => { e.preventDefault(); onDown(e.changedTouches[0].clientX); }, {passive:false});
  viewport.addEventListener('touchmove',  e => { e.preventDefault(); onMove(e.changedTouches[0].clientX); }, {passive:false});
  viewport.addEventListener('touchend', e => { e.preventDefault(); onUp(); }, {passive:false});

  viewport.tabIndex = 0;
  viewport.addEventListener('keydown', e => {
    if (e.key === 'ArrowRight') { next(); resetAutoSlide(); }
    if (e.key === 'ArrowLeft') { prev(); resetAutoSlide(); }
  });

  window.addEventListener('resize', update);

  function startAutoSlide() {
    autoSlide = setInterval(() => { next(); }, 4000); // 4 seconds
  }
  function resetAutoSlide() {
    clearInterval(autoSlide);
    startAutoSlide();
  }

  update();
  startAutoSlide();
</script>
</body>
</html>
